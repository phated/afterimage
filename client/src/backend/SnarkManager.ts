import FastQueue from 'fastq';
import type { EthAddress } from '@darkforest_eth/types';

/**
 * A zkSNARK proof (without signals) generated by snarkJS `fullProve`
 */
export interface SnarkJSProof {
  pi_a: [string, string, string];
  pi_b: [[string, string], [string, string], [string, string]];
  pi_c: [string, string, string];
}

/**
 * A zkSNARK proof and corresponding public signals generated by snarkJS
 * `fullProve`
 */
export interface SnarkJSProofAndSignals {
  proof: SnarkJSProof;
  publicSignals: string[];
}

export interface InitSnarkInput {
  x: string;
  y: string;
  blockhash: string;
  possibleHashes: string[];
  possibleHashesHash: string;
  salt: string;
  saltUpperBound: string;
  gridUpperBound: string;
  commitment: string;
}

export interface MoveSnarkInput {
  oldX: string;
  oldY: string;
  oldSalt: string;
  oldCommitment: string;
  newX: string;
  newY: string;
  newBlockhash: string;
  possibleHashes: string[];
  possibleHashesHash: string;
  newSalt: string;
  saltUpperBound: string;
  gridUpperBound: string;
  newCommitment: string;
}

export interface BattleSnarkInput {
  myX: string;
  myY: string;
  mySalt: string;
  myCommitment: string;
  yourX: string;
  yourY: string;
  yourSalt: string;
  yourCommitment: string;
}

export type ContractCallArgs = [
  string,
  string,
  [string, string], // proofA
  [
    // proofB
    [string, string],
    [string, string]
  ],
  [string, string], // proofC
  [
    string, // hashed whitelist key
    string // recipient address
  ]
];

export type BattleContractCallArgs = [
  string,
  [string, string], // proofA
  [
    // proofB
    [string, string],
    [string, string]
  ],
  [string, string], // proofC
  [
    string, // hashed whitelist key
    string // recipient address
  ]
];

/**
 * Method for converting the output of snarkJS `fullProve` into args that can be
 * passed into DarkForest smart contract functions which perform zk proof
 * verification.
 *
 * @param snarkProof the SNARK proof
 * @param publicSignals the circuit's public signals (i.e. output signals and
 * public input signals)
 */
export function buildContractCallArgs(
  blockNumberLower: string,
  blockNumberUpper: string,
  snarkProof: SnarkJSProof,
  publicSignals: string[]
): ContractCallArgs {
  // the object returned by genZKSnarkProof needs to be massaged into a set of parameters the verifying contract
  // will accept
  return [
    blockNumberLower,
    blockNumberUpper,
    snarkProof.pi_a.slice(0, 2), // pi_a
    // genZKSnarkProof reverses values in the inner arrays of pi_b
    [snarkProof.pi_b[0].slice(0).reverse(), snarkProof.pi_b[1].slice(0).reverse()], // pi_b
    snarkProof.pi_c.slice(0, 2), // pi_c
    publicSignals, // input
  ] as ContractCallArgs;
}

/**
 * Method for converting the output of snarkJS `fullProve` into args that can be
 * passed into DarkForest smart contract functions which perform zk proof
 * verification.
 *
 * @param snarkProof the SNARK proof
 * @param publicSignals the circuit's public signals (i.e. output signals and
 * public input signals)
 */
export function buildBattleContractCallArgs(
  playerAddr: EthAddress,
  snarkProof: SnarkJSProof,
  publicSignals: string[]
): BattleContractCallArgs {
  // the object returned by genZKSnarkProof needs to be massaged into a set of parameters the verifying contract
  // will accept
  return [
    playerAddr.toString(),
    snarkProof.pi_a.slice(0, 2), // pi_a
    // genZKSnarkProof reverses values in the inner arrays of pi_b
    [snarkProof.pi_b[0].slice(0).reverse(), snarkProof.pi_b[1].slice(0).reverse()], // pi_b
    snarkProof.pi_c.slice(0, 2), // pi_c
    publicSignals, // input
  ] as BattleContractCallArgs;
}

type ZKPTask = {
  taskId: number;
  input: unknown;
  circuit: string; // path
  zkey: string; // path

  onSuccess: (proof: SnarkJSProofAndSignals) => void;
  onError: (e: Error) => void;
};

type SnarkInput = InitSnarkInput | MoveSnarkInput | BattleSnarkInput;

export class SnarkProverQueue {
  private taskQueue: FastQueue.queue;
  private taskCount: number;

  constructor() {
    this.taskQueue = FastQueue(this.execute.bind(this), 1);
    this.taskCount = 0;
  }

  public doProof(
    input: SnarkInput,
    circuit: string,
    zkey: string
  ): Promise<SnarkJSProofAndSignals> {
    const taskId = this.taskCount++;
    const task = {
      input,
      circuit,
      zkey,
      taskId,
    };

    return new Promise<SnarkJSProofAndSignals>((resolve, reject) => {
      this.taskQueue.push(task, (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
  }

  private async execute(
    task: ZKPTask,
    cb: (err: Error | null, result: SnarkJSProofAndSignals | null) => void
  ) {
    try {
      console.log(`proving ${task.taskId}`);
      const res = await window.snarkjs.groth16.fullProve(task.input, task.circuit, task.zkey);
      console.log(`proved ${task.taskId}`);
      cb(null, res);
    } catch (e) {
      console.error('error while calculating SNARK proof:');
      console.error(e);
      cb(e as Error, null);
    }
  }
}
